# 后端开发规范 (Java + Spring Boot)

## 1. 技术栈

### 1.1 核心技术
- **语言**: Java 21 (LTS)
- **框架**: Spring Boot 3.2+
- **微服务**: Spring Cloud 2023.x
- **ORM**: MyBatis-Plus 3.5+
- **数据库**: PostgreSQL 16 / MySQL 8.0
- **缓存**: Redis 7
- **消息队列**: RabbitMQ 3.12
- **服务注册与配置**: Nacos 3.0

### 1.2 工具库
- **构建工具**: Maven 3.9+
- **API 文档**: Knife4j (Swagger 3)
- **工具类**: Hutool 5.8+
- **日期处理**: Java 8 Time API
- **JSON**: Jackson
- **日志**: Logback + SLF4J

---

## 2. 项目结构规范

详见 `01-项目结构规范.md` 的后端部分

---

## 3. 包结构规范

### 3.1 标准分层结构

```
com.xiwen.{service-name}/
├── config/                 # 配置类
│   ├── SecurityConfig.java
│   ├── RedisConfig.java
│   └── MyBatisConfig.java
│
├── controller/             # 控制器层（REST API）
│   ├── AuthController.java
│   └── UserController.java
│
├── service/                # 业务逻辑层
│   ├── UserService.java
│   └── impl/
│       └── UserServiceImpl.java
│
├── mapper/                 # 数据访问层（MyBatis）
│   └── UserMapper.java
│
├── entity/                 # 实体类（对应数据库表）
│   └── User.java
│
├── dto/                    # 数据传输对象
│   ├── request/            # 请求 DTO
│   │   ├── CreateUserRequest.java
│   │   └── UpdateUserRequest.java
│   └── response/           # 响应 DTO
│       └── UserVO.java
│
├── enums/                  # 枚举类
│   ├── UserStatus.java
│   └── ErrorCode.java
│
├── exception/              # 自定义异常
│   ├── BusinessException.java
│   └── GlobalExceptionHandler.java
│
├── util/                   # 工具类
│   ├── JwtUtil.java
│   └── PasswordUtil.java
│
├── constant/               # 常量类
│   └── RedisKey.java
│
└── AuthCenterApplication.java  # 启动类
```

---

## 4. 编码规范

### 4.1 命名规范

#### 类命名
```java
// Controller：名词 + Controller
UserController, AuthController

// Service：名词 + Service
UserService, AuthService

// ServiceImpl：名词 + ServiceImpl
UserServiceImpl

// Mapper：名词 + Mapper
UserMapper

// Entity：名词（单数）
User, Order

// DTO Request：动词 + 名词 + Request
CreateUserRequest, UpdateUserRequest

// DTO Response/VO：名词 + VO
UserVO, OrderVO

// Exception：名词 + Exception
BusinessException, ResourceNotFoundException

// Config：名词 + Config
RedisConfig, SecurityConfig

// Util：名词 + Util
JwtUtil, DateUtil

// Constant：名词 + Constant
RedisKeyConstant
```

#### 方法命名
```java
// 查询
User getById(Long id)
List<User> list()
PageResult<User> page(PageParams params)
User getByUsername(String username)
boolean exists(Long id)

// 创建
User create(CreateUserRequest request)
void save(User user)
void batchSave(List<User> users)

// 更新
User update(Long id, UpdateUserRequest request)
void updateStatus(Long id, UserStatus status)

// 删除
void delete(Long id)
void batchDelete(List<Long> ids)

// 业务方法
void login(String username, String password)
void logout()
void sendVerificationCode(String email)
```

#### 变量命名
```java
// 常量：大写下划线
public static final String DEFAULT_PASSWORD = "123456";
public static final int MAX_RETRY_COUNT = 3;

// 变量/参数：小驼峰
String userName;
Long userId;
List<User> userList;

// 布尔值：is/has/can 开头
boolean isActive;
boolean hasPermission;
boolean canDelete;

// 集合：复数或 List/Map 结尾
List<User> users;
List<User> userList;
Map<Long, User> userMap;
```

### 4.2 注解规范

#### Controller 注解
```java
@Tag(name = "用户管理", description = "用户相关接口")
@RestController
@RequestMapping("/api/v1/users")
@RequiredArgsConstructor
@Validated
public class UserController {

    private final UserService userService;

    @Operation(summary = "获取用户列表", description = "分页查询用户列表")
    @GetMapping
    public ApiResponse<PageResult<UserVO>> list(
            @Parameter(description = "页码") @RequestParam(defaultValue = "1") Integer pageNum,
            @Parameter(description = "每页数量") @RequestParam(defaultValue = "10") Integer pageSize) {
        // ...
    }

    @Operation(summary = "创建用户")
    @PostMapping
    public ApiResponse<UserVO> create(@Valid @RequestBody CreateUserRequest request) {
        // ...
    }
}
```

#### Service 注解
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {

    private final UserMapper userMapper;
    private final RedisTemplate<String, Object> redisTemplate;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public User create(CreateUserRequest request) {
        // ...
    }

    @Override
    @Cacheable(value = "user", key = "#id")
    public User getById(Long id) {
        // ...
    }
}
```

---

## 5. 分层职责

### 5.1 Controller 层

**职责：**
- 接收 HTTP 请求
- 参数验证
- 调用 Service
- 返回响应

**规范：**
```java
@RestController
@RequestMapping("/api/v1/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @PostMapping
    public ApiResponse<UserVO> create(@Valid @RequestBody CreateUserRequest request) {
        // ✅ 只做参数验证和服务调用
        UserVO user = userService.create(request);
        return ApiResponse.success(user);
    }

    // ❌ 不要在 Controller 写业务逻辑
    @PostMapping("/wrong")
    public ApiResponse<UserVO> createWrong(@RequestBody CreateUserRequest request) {
        // ❌ 错误：业务逻辑应该在 Service
        User user = new User();
        user.setUsername(request.getUsername());
        user.setPassword(PasswordUtil.encode(request.getPassword()));
        userMapper.insert(user);
        return ApiResponse.success(UserVO.from(user));
    }
}
```

### 5.2 Service 层

**职责：**
- 业务逻辑处理
- 事务管理
- 调用 Mapper
- 缓存处理

**规范：**
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {

    private final UserMapper userMapper;
    private final PasswordEncoder passwordEncoder;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public UserVO create(CreateUserRequest request) {
        // 1. 校验业务规则
        if (userMapper.existsByUsername(request.getUsername())) {
            throw new BusinessException(ErrorCode.USERNAME_EXISTS);
        }

        // 2. 构建实体
        User user = new User();
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));

        // 3. 保存数据
        userMapper.insert(user);

        // 4. 返回 VO
        return UserVO.from(user);
    }

    @Override
    @Cacheable(value = "user", key = "#id")
    public UserVO getById(Long id) {
        User user = userMapper.selectById(id);
        if (user == null) {
            throw new BusinessException(ErrorCode.USER_NOT_FOUND);
        }
        return UserVO.from(user);
    }
}
```

### 5.3 Mapper 层

**职责：**
- 数据库操作
- SQL 映射

**规范：**
```java
@Mapper
public interface UserMapper extends BaseMapper<User> {

    // 简单查询使用 MyBatis-Plus 提供的方法
    // selectById, selectList, insert, updateById, deleteById

    // 复杂查询自定义方法
    @Select("SELECT * FROM user WHERE username = #{username}")
    User selectByUsername(@Param("username") String username);

    // 关联查询使用 XML
    List<UserWithRoles> selectUsersWithRoles(@Param("params") Map<String, Object> params);

    boolean existsByUsername(@Param("username") String username);
}
```

---

## 6. 实体类规范

### 6.1 Entity（实体类）

```java
@Data
@TableName("user")
public class User {

    @TableId(type = IdType.AUTO)
    private Long id;

    @TableField("username")
    private String username;

    @TableField("email")
    private String email;

    @TableField("password")
    @JsonIgnore  // 不返回给前端
    private String password;

    @TableField("avatar")
    private String avatar;

    @TableField("status")
    private UserStatus status;

    @TableField(value = "created_at", fill = FieldFill.INSERT)
    private LocalDateTime createdAt;

    @TableField(value = "updated_at", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedAt;

    @TableField(exist = false)  // 不是数据库字段
    private transient List<String> roles;
}
```

### 6.2 Request DTO

```java
@Data
public class CreateUserRequest {

    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20个字符之间")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "用户名只能包含字母、数字和下划线")
    private String username;

    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;

    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20个字符之间")
    private String password;

    private String avatar;
}
```

### 6.3 Response DTO (VO)

```java
@Data
@Builder
public class UserVO {

    private Long id;
    private String username;
    private String email;
    private String avatar;
    private UserStatus status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // 从 Entity 转换
    public static UserVO from(User user) {
        return UserVO.builder()
                .id(user.getId())
                .username(user.getUsername())
                .email(user.getEmail())
                .avatar(user.getAvatar())
                .status(user.getStatus())
                .createdAt(user.getCreatedAt())
                .updatedAt(user.getUpdatedAt())
                .build();
    }
}
```

---

## 7. 统一响应处理

### 7.1 ApiResponse

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {

    private Integer code;
    private String message;
    private T data;
    private Long timestamp;

    public static <T> ApiResponse<T> success(T data) {
        return ApiResponse.<T>builder()
                .code(200)
                .message("success")
                .data(data)
                .timestamp(System.currentTimeMillis())
                .build();
    }

    public static <T> ApiResponse<T> success() {
        return success(null);
    }

    public static <T> ApiResponse<T> error(Integer code, String message) {
        return ApiResponse.<T>builder()
                .code(code)
                .message(message)
                .data(null)
                .timestamp(System.currentTimeMillis())
                .build();
    }

    public static <T> ApiResponse<T> error(ErrorCode errorCode) {
        return error(errorCode.getCode(), errorCode.getMessage());
    }
}
```

### 7.2 分页响应

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResult<T> {

    private List<T> list;
    private Long total;
    private Integer pageNum;
    private Integer pageSize;
    private Integer pages;

    public static <T> PageResult<T> of(IPage<T> page) {
        return PageResult.<T>builder()
                .list(page.getRecords())
                .total(page.getTotal())
                .pageNum((int) page.getCurrent())
                .pageSize((int) page.getSize())
                .pages((int) page.getPages())
                .build();
    }
}
```

---

## 8. 异常处理

### 8.1 业务异常

```java
@Getter
public class BusinessException extends RuntimeException {

    private final Integer code;

    public BusinessException(Integer code, String message) {
        super(message);
        this.code = code;
    }

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.code = errorCode.getCode();
    }
}
```

### 8.2 错误码枚举

```java
@Getter
@AllArgsConstructor
public enum ErrorCode {

    // 通用错误
    SUCCESS(200, "成功"),
    PARAM_ERROR(40000, "请求参数错误"),
    RESOURCE_EXISTS(40001, "资源已存在"),
    RESOURCE_NOT_FOUND(40002, "资源不存在"),
    BUSINESS_ERROR(40003, "业务逻辑错误"),

    // 认证授权
    UNAUTHORIZED(41000, "未登录"),
    TOKEN_INVALID(41001, "Token 无效"),
    TOKEN_EXPIRED(41002, "Token 过期"),

    FORBIDDEN(43000, "无权限访问"),

    // 服务器错误
    INTERNAL_ERROR(50000, "服务器内部错误"),
    DATABASE_ERROR(50001, "数据库错误"),
    THIRD_PARTY_ERROR(50002, "第三方服务错误"),

    // 业务错误
    USERNAME_EXISTS(40101, "用户名已存在"),
    USER_NOT_FOUND(40102, "用户不存在"),
    PASSWORD_ERROR(40103, "密码错误");

    private final Integer code;
    private final String message;
}
```

### 8.3 全局异常处理

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    // 参数验证异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Map<String, List<String>>>> handleValidationException(
            MethodArgumentNotValidException ex) {

        Map<String, List<String>> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            errors.computeIfAbsent(error.getField(), k -> new ArrayList<>())
                    .add(error.getDefaultMessage());
        });

        return ResponseEntity.badRequest()
                .body(ApiResponse.error(ErrorCode.PARAM_ERROR.getCode(), "参数验证失败"));
    }

    // 业务异常
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Void>> handleBusinessException(BusinessException ex) {
        log.warn("Business exception: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY)
                .body(ApiResponse.error(ex.getCode(), ex.getMessage()));
    }

    // 数据库异常
    @ExceptionHandler(DataAccessException.class)
    public ResponseEntity<ApiResponse<Void>> handleDataAccessException(DataAccessException ex) {
        log.error("Database error", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error(ErrorCode.DATABASE_ERROR));
    }

    // 未知异常
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleException(Exception ex) {
        log.error("Unexpected error", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error(ErrorCode.INTERNAL_ERROR));
    }
}
```

---

## 9. 配置管理

### 9.1 application.yml

```yaml
spring:
  application:
    name: auth-center

  profiles:
    active: dev

  datasource:
    driver-class-name: org.postgresql.Driver
    url: jdbc:postgresql://localhost:5432/auth_center
    username: postgres
    password: postgres

  redis:
    host: localhost
    port: 6379
    password: pass-redis
    database: 0

mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      id-type: auto
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0

# Knife4j 配置
knife4j:
  enable: true
  openapi:
    title: 认证中心 API
    version: 1.0.0
    description: 用户认证和授权服务
```

### 9.2 bootstrap.yml (Nacos)

```yaml
spring:
  application:
    name: auth-center
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: public
        group: DEFAULT_GROUP
      config:
        server-addr: localhost:8848
        namespace: public
        group: DEFAULT_GROUP
        file-extension: yaml
        refresh-enabled: true
```

---

## 10. 日志规范

### 10.1 日志级别

```java
@Service
@Slf4j
public class UserServiceImpl implements UserService {

    @Override
    public UserVO create(CreateUserRequest request) {
        // DEBUG：调试信息
        log.debug("Creating user with username: {}", request.getUsername());

        // INFO：重要业务操作
        log.info("User created successfully, id: {}", user.getId());

        // WARN：警告信息
        if (userCount > 10000) {
            log.warn("User count exceeds 10000: {}", userCount);
        }

        // ERROR：错误信息（带异常）
        try {
            // ...
        } catch (Exception e) {
            log.error("Failed to create user", e);
            throw new BusinessException(ErrorCode.INTERNAL_ERROR);
        }
    }
}
```

### 10.2 日志格式

```xml
<!-- logback-spring.xml -->
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/auth-center.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/auth-center.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

---

## 11. 数据库规范

### 11.1 表设计规范

```sql
-- 表名：小写下划线
-- 主键：id（自增 BIGINT）
-- 时间字段：created_at, updated_at
-- 软删除：deleted（0: 未删除, 1: 已删除）

CREATE TABLE user (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    avatar VARCHAR(255),
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted SMALLINT NOT NULL DEFAULT 0
);

-- 索引
CREATE INDEX idx_user_username ON user(username);
CREATE INDEX idx_user_email ON user(email);
CREATE INDEX idx_user_status ON user(status);
```

### 11.2 数据库迁移（Flyway）

```sql
-- V1__create_user_table.sql
CREATE TABLE user (
    -- ...
);

-- V2__add_user_avatar.sql
ALTER TABLE user ADD COLUMN avatar VARCHAR(255);

-- V3__create_role_table.sql
CREATE TABLE role (
    -- ...
);
```

---

## 12. 缓存规范

### 12.1 缓存使用

```java
@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserMapper userMapper;
    private final RedisTemplate<String, Object> redisTemplate;

    // 使用 Spring Cache 注解
    @Override
    @Cacheable(value = "user", key = "#id")
    public UserVO getById(Long id) {
        User user = userMapper.selectById(id);
        return UserVO.from(user);
    }

    @Override
    @CacheEvict(value = "user", key = "#id")
    public void delete(Long id) {
        userMapper.deleteById(id);
    }

    // 手动操作 Redis
    @Override
    public void saveToken(Long userId, String token) {
        String key = RedisKeyConstant.USER_TOKEN + userId;
        redisTemplate.opsForValue().set(key, token, 7, TimeUnit.DAYS);
    }
}
```

### 12.2 Redis Key 规范

```java
public class RedisKeyConstant {

    // 格式：模块:业务:标识
    public static final String USER_TOKEN = "user:token:";
    public static final String USER_INFO = "user:info:";
    public static final String VERIFY_CODE = "auth:code:";

    // 使用示例：user:token:123
}
```

---

## 13. 测试规范

### 13.1 单元测试

```java
@SpringBootTest
class UserServiceTest {

    @Autowired
    private UserService userService;

    @MockBean
    private UserMapper userMapper;

    @Test
    @DisplayName("创建用户 - 成功")
    void createUser_success() {
        // Given
        CreateUserRequest request = new CreateUserRequest();
        request.setUsername("testuser");
        request.setEmail("test@example.com");
        request.setPassword("password123");

        User savedUser = new User();
        savedUser.setId(1L);
        savedUser.setUsername("testuser");

        when(userMapper.existsByUsername(anyString())).thenReturn(false);
        when(userMapper.insert(any(User.class))).thenReturn(1);

        // When
        UserVO result = userService.create(request);

        // Then
        assertNotNull(result);
        assertEquals("testuser", result.getUsername());
        verify(userMapper, times(1)).insert(any(User.class));
    }

    @Test
    @DisplayName("创建用户 - 用户名已存在")
    void createUser_usernameExists() {
        // Given
        CreateUserRequest request = new CreateUserRequest();
        request.setUsername("existinguser");

        when(userMapper.existsByUsername("existinguser")).thenReturn(true);

        // When & Then
        assertThrows(BusinessException.class, () -> {
            userService.create(request);
        });
    }
}
```

---

## 14. 性能优化

### 14.1 SQL 优化
- 使用索引
- 避免 N+1 查询
- 分页查询
- 批量操作

### 14.2 缓存策略
- 热点数据缓存
- 缓存预热
- 缓存过期策略
- 缓存穿透/雪崩防护

### 14.3 异步处理
```java
@Service
@RequiredArgsConstructor
public class EmailService {

    @Async
    public CompletableFuture<Void> sendEmail(String to, String subject, String content) {
        // 发送邮件
        return CompletableFuture.completedFuture(null);
    }
}
```

---

## 15. 安全规范

### 15.1 密码处理
```java
@Component
public class PasswordEncoder {

    public String encode(String rawPassword) {
        return BCrypt.hashpw(rawPassword, BCrypt.gensalt());
    }

    public boolean matches(String rawPassword, String encodedPassword) {
        return BCrypt.checkpw(rawPassword, encodedPassword);
    }
}
```

### 15.2 SQL 注入防护
```java
// ✅ 使用参数化查询
@Select("SELECT * FROM user WHERE username = #{username}")
User selectByUsername(@Param("username") String username);

// ❌ 不要拼接 SQL
@Select("SELECT * FROM user WHERE username = '" + username + "'")
```

### 15.3 敏感信息
- 密码加密存储
- Token 加密传输
- 日志不记录敏感信息
- 配置文件不提交密码

---

## 16. 最佳实践

### ✅ DO
- 使用 Lombok 简化代码
- 使用 @RequiredArgsConstructor 注入
- Controller 只做参数验证和调用
- Service 包含业务逻辑
- 使用事务注解
- 异常必须处理
- 日志记录关键操作
- 编写单元测试

### ❌ DON'T
- 不要在 Controller 写业务逻辑
- 不要在 Mapper 写业务逻辑
- 不要捕获异常后不处理
- 不要返回 null（使用 Optional）
- 不要使用 SELECT *
- 不要在循环中查数据库
- 不要硬编码配置
- 不要提交敏感信息到 Git

---

> **版本**: v1.0
> **更新日期**: 2026-02-05
> **维护者**: AI Assistant
